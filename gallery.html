<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Media Gallery</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
        }

        .hidden {
            display: none !important;
        }

        .controls {
            padding: 15px;
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .controls button, .controls label {
            padding: 8px 15px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background-color: #f7f7f7;
            cursor: pointer;
            font-size: 14px;
        }

        .controls button:hover {
            background-color: #dcdfe3;
        }

        .grid {
            margin: 0 auto;
        }

        .grid-item {
            margin-bottom: 10px;
            box-sizing: border-box;
            overflow: hidden;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }

        .grid-item:hover .action-icon {
            opacity: 1;
        }

        .grid-item img,
        .grid-item video {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
            cursor: pointer;
        }

        .action-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .action-icon:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .trash-view {
            padding: 20px;
            text-align: center;
        }

        .trash-controls {
            margin-bottom: 20px;
        }

        .error {
            text-align: center;
            padding: 40px;
            color: #d32f2f;
            font-size: 16px;
        }

        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 2000;
        }

        #unsupported-files-container {
            padding: 10px 20px;
            background: #fffbe6;
            border-bottom: 1px solid #ffe58f;
        }

        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .fullscreen-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .fullscreen-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }
        .fullscreen-content img,
        .fullscreen-content video {
            max-width: calc(100vw - 20px);
            max-height: calc(100vh - 20px);
            object-fit: contain;
            border-radius: 4px;
        }
        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            z-index: 1002;
        }
        .nav-btn:hover { background-color: white; transform: translateY(-50%) scale(1.1); }
        .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: translateY(-50%) scale(0.9); }
        .prev-btn { left: 20px; }
        .next-btn { right: 20px; }
        .close-btn { position: absolute; top: 20px; right: 30px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer; z-index: 1002; }
        .media-info { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: white; background-color: rgba(0, 0, 0, 0.7); padding: 4px 12px; border-radius: 15px; font-size: 12px; z-index: 1002; pointer-events: none; }
    </style>
</head>
<body>
    <div id="loadingIndicator" class="hidden">Loading...</div>
    <div id="unsupported-files-container" class="hidden"></div>
    <div class="controls">
        <button id="back-to-home-btn">Back to Home</button>
        <button id="viewTrashBtn">View Trash (0)</button>
        <button id="backToGalleryBtn" class="hidden">Back to Gallery</button>
        <div>
            <label for="columnCountSlider">Columns:</label>
            <input type="range" id="columnCountSlider" min="2" max="10" value="4">
            <span id="columnCountValue">4</span>
        </div>
        <div>
            <input type="checkbox" id="autoTrashCheckbox">
            <label for="autoTrashCheckbox">Auto-trash viewed files</label>
        </div>
    </div>

    <div class="grid"></div>
    <div class="trash-view hidden">
        <h2>Trash</h2>
        <div class="trash-controls">
            <button id="permanentlyDeleteBtn">Permanently Delete Trashed Files</button>
            <p id="delete-status" class="hidden"></p>
        </div>
        <div class="grid" id="trashGrid"></div>
    </div>

    <div id="fullscreenOverlay" class="fullscreen-overlay">
        <span class="close-btn">&times;</span>
        <button class="nav-btn prev-btn" id="prevBtn">‹</button>
        <button class="nav-btn next-btn" id="nextBtn">›</button>
        <div class="fullscreen-content"></div>
        <div class="media-info" id="mediaInfo"></div>
        <div class="action-icon" id="fullscreenDeleteBtn" title="Mark for Deletion">&#128465;</div>
    </div>

    <script src="js/masonry.pkgd.min.js"></script>
    <script src="js/imagesloaded.pkgd.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // State
            let allFiles = [], visibleFiles = [], trashedFiles = [];
            let currentView = 'gallery', masonry, trashMasonry;

            // DOM Elements
            const { ipcRenderer } = require('electron');
            const backToHomeBtn = document.getElementById('back-to-home-btn');
            const viewTrashBtn = document.getElementById('viewTrashBtn');
            const backToGalleryBtn = document.getElementById('backToGalleryBtn');
            const autoTrashCheckbox = document.getElementById('autoTrashCheckbox');
            const mainGrid = document.querySelector('.grid');
            const trashView = document.querySelector('.trash-view');
            const trashGrid = document.getElementById('trashGrid');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const unsupportedContainer = document.getElementById('unsupported-files-container');
            const fullscreenOverlay = document.getElementById('fullscreenOverlay');
            const fullscreenContent = document.querySelector('.fullscreen-content');
            const closeFullscreenBtn = document.querySelector('.fullscreen-overlay .close-btn');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const mediaInfo = document.getElementById('mediaInfo');
            const fullscreenDeleteBtn = document.getElementById('fullscreenDeleteBtn');
            const columnCountSlider = document.getElementById('columnCountSlider');
            const columnCountValue = document.getElementById('columnCountValue');

            const supportedExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.mp4', '.webm', '.ogg'];

            // --- Event Listeners ---
            backToHomeBtn.addEventListener('click', () => { window.location.href = 'index.html'; });
            viewTrashBtn.addEventListener('click', showTrashView);
            backToGalleryBtn.addEventListener('click', showGalleryView);
            document.getElementById('permanentlyDeleteBtn').addEventListener('click', deleteTrashedFiles);
            columnCountSlider.addEventListener('input', () => {
                columnCountValue.textContent = columnCountSlider.value;
                updateLayout();
            });
            window.addEventListener('resize', updateLayout);

            // --- Initialization ---
            function initializePage() {
                const folderPath = sessionStorage.getItem('mediaFolderPath');
                const viewMode = sessionStorage.getItem('viewMode');

                if (!folderPath) {
                    alert("No media folder selected. Returning to home page.");
                    window.location.href = 'index.html';
                    return;
                }

                // Load persisted trash from localStorage
                const storedTrash = JSON.parse(localStorage.getItem(`trash_${folderPath}`) || '[]');
                trashedFiles = storedTrash.map(id => ({ id, url: `file://${id}` }));

                loadMediaFromPath(folderPath, viewMode);
            }

            // --- Core Functions ---
            async function loadMediaFromPath(folderPath, viewMode) {
                loadingIndicator.classList.remove('hidden');
                unsupportedContainer.classList.add('hidden');
                unsupportedContainer.innerHTML = '';

                const filePaths = await ipcRenderer.invoke('open-folder-dialog', folderPath);
                if (!filePaths || filePaths.length === 0) {
                    mainGrid.innerHTML = '<div class="error">Could not read the selected folder.</div>';
                    loadingIndicator.classList.add('hidden');
                    return;
                }

                const supportedFiles = [];
                const unsupportedFiles = [];
                filePaths.forEach(path => {
                    const extension = (path.split('.').pop() || '').toLowerCase();
                    if (supportedExtensions.includes(`.${extension}`)) {
                        supportedFiles.push(path);
                    } else {
                        unsupportedFiles.push(path);
                    }
                });

                if (unsupportedFiles.length > 0) {
                    const listItems = unsupportedFiles.map(f => `<li>${f.split(/[/\\]/).pop()}</li>`).join('');
                    unsupportedContainer.innerHTML = `<strong>Unsupported Files (not loaded):</strong><ul>${listItems}</ul>`;
                    unsupportedContainer.classList.remove('hidden');
                }

                allFiles = supportedFiles.map(filePath => ({ id: filePath, url: `file://${filePath}` }));

                // Filter out any files that are already in the trash
                const trashedIds = new Set(trashedFiles.map(f => f.id));
                visibleFiles = allFiles.filter(f => !trashedIds.has(f.id));

                updateTrashButton();

                if (viewMode === 'trash') {
                    showTrashView();
                } else {
                    showGalleryView();
                }
            }

            function renderGrid(container, files, isTrash) {
                container.innerHTML = '';
                let msnry = isTrash ? trashMasonry : masonry;
                if (msnry) msnry.destroy();

                if (files.length === 0) {
                    container.innerHTML = `<div class="error">${isTrash ? 'Trash is empty.' : 'No media to display.'}</div>`;
                    loadingIndicator.classList.add('hidden');
                    return;
                }

                const elements = files.map(fileObj => {
                    const gridItem = document.createElement('div');
                    gridItem.classList.add('grid-item');
                    const mediaElement = createMediaElement(fileObj);
                    const actionIcon = createActionIcon(fileObj, isTrash);
                    gridItem.appendChild(mediaElement);
                    gridItem.appendChild(actionIcon);
                    mediaElement.addEventListener('click', () => openFullscreen(fileObj));
                    return gridItem;
                });

                container.append(...elements);

                msnry = new Masonry(container, { itemSelector: '.grid-item', gutter: 10 });
                updateLayout(msnry);
                imagesLoaded(container).on('always', () => {
                    msnry.layout();
                    loadingIndicator.classList.add('hidden');
                });

                if (isTrash) trashMasonry = msnry;
                else masonry = msnry;
            }

            function updateLayout(msnryInstance = null) {
                const msnry = msnryInstance || (currentView === 'trash' ? trashMasonry : masonry);
                if (!msnry || !msnry.element) return;

                const numColumns = parseInt(columnCountSlider.value);
                const containerWidth = msnry.element.parentElement.clientWidth;
                const gutter = 10;
                const itemWidth = Math.floor((containerWidth - (gutter * (numColumns + 1))) / numColumns);

                msnry.options.columnWidth = itemWidth;
                msnry.element.querySelectorAll('.grid-item').forEach(item => {
                    item.style.width = `${itemWidth}px`;
                });

                msnry.layout();
            }

            function createActionIcon(fileObj, isTrash) {
                const actionIcon = document.createElement('div');
                actionIcon.classList.add('action-icon');
                if (isTrash) {
                    actionIcon.innerHTML = '&#128472;';
                    actionIcon.title = 'Restore from trash';
                    actionIcon.addEventListener('click', e => { e.stopPropagation(); restoreFromTrash(fileObj.id); });
                } else {
                    actionIcon.innerHTML = '&#128465;';
                    actionIcon.title = 'Mark for deletion';
                    actionIcon.addEventListener('click', e => { e.stopPropagation(); markForDeletion(fileObj.id); });
                }
                return actionIcon;
            }

            function createMediaElement(fileObj) {
                const lowerFileName = fileObj.id.toLowerCase();
                const isVideo = ['.mp4', '.webm', '.ogg'].some(ext => lowerFileName.endsWith(ext));
                const mediaElement = isVideo ? document.createElement('video') : document.createElement('img');
                if (isVideo) {
                    mediaElement.autoplay = true;
                    mediaElement.muted = true;
                    mediaElement.loop = true;
                }
                mediaElement.src = fileObj.url;
                return mediaElement;
            }

            function updateTrashPersistence() {
                const folderPath = sessionStorage.getItem('mediaFolderPath');
                if(folderPath) {
                    const trashedIds = trashedFiles.map(f => f.id);
                    localStorage.setItem(`trash_${folderPath}`, JSON.stringify(trashedIds));
                }
            }

            function markForDeletion(fileId) {
                const index = visibleFiles.findIndex(f => f.id === fileId);
                if (index > -1) {
                    const [fileToTrash] = visibleFiles.splice(index, 1);
                    trashedFiles.push(fileToTrash);
                    renderGrid(mainGrid, visibleFiles, false);
                    updateTrashButton();
                    updateTrashPersistence();
                }
            }

            function restoreFromTrash(fileId) {
                const index = trashedFiles.findIndex(f => f.id === fileId);
                if (index > -1) {
                    const [fileToRestore] = trashedFiles.splice(index, 1);
                    visibleFiles.push(fileToRestore);
                    renderGrid(trashGrid, trashedFiles, true);
                    updateTrashButton();
                    updateTrashPersistence();
                }
            }

            function updateTrashButton() {
                viewTrashBtn.textContent = `View Trash (${trashedFiles.length})`;
            }

            function showGalleryView() {
                currentView = 'gallery';
                mainGrid.classList.remove('hidden');
                trashView.classList.add('hidden');
                viewTrashBtn.classList.remove('hidden');
                backToGalleryBtn.classList.add('hidden');
                renderGrid(mainGrid, visibleFiles, false);
            }

            function showTrashView() {
                currentView = 'trash';
                mainGrid.classList.add('hidden');
                trashView.classList.remove('hidden');
                viewTrashBtn.classList.add('hidden');
                backToGalleryBtn.classList.remove('hidden');
                renderGrid(trashGrid, trashedFiles, true);
            }

            async function deleteTrashedFiles() {
                if (trashedFiles.length === 0) return alert("Trash is empty.");
                const filePaths = trashedFiles.map(f => f.id);
                const confirm = localStorage.getItem('confirmDelete') !== 'false';

                const result = await ipcRenderer.invoke('delete-files', { filePaths, confirm });

                const deleteStatus = document.getElementById('delete-status');
                if (result.success) {
                    deleteStatus.textContent = `Successfully deleted ${result.deletedCount} files.`;
                    deleteStatus.style.color = 'green';
                    trashedFiles = [];
                    renderGrid(trashGrid, trashedFiles, true);
                    updateTrashButton();
                    updateTrashPersistence();
                } else {
                    deleteStatus.textContent = `Error: ${result.error}`;
                    deleteStatus.style.color = 'red';
                }
                deleteStatus.classList.remove('hidden');
                setTimeout(() => deleteStatus.classList.add('hidden'), 5000);
            }

            // --- Fullscreen Logic ---
            let currentMediaId = null, currentMediaIndex = -1, currentMediaList = [];

            function openFullscreen(fileObj) {
                currentMediaId = fileObj.id;
                currentMediaList = (currentView === 'trash') ? trashedFiles : visibleFiles;
                currentMediaIndex = currentMediaList.findIndex(f => f.id === fileObj.id);
                const isVideo = ['.mp4', '.webm', '.ogg'].some(ext => fileObj.id.toLowerCase().endsWith(ext));

                fullscreenContent.innerHTML = '';
                const mediaElement = createMediaElement(fileObj);
                if(isVideo) {
                    mediaElement.autoplay = true;
                    mediaElement.muted = false;
                    mediaElement.controls = true;
                }
                fullscreenContent.appendChild(mediaElement);
                updateFullscreenDeleteIcon();
                updateNavigationState();
                fullscreenOverlay.classList.add('visible');
                if (autoTrashCheckbox.checked && !trashedFiles.some(f => f.id === fileObj.id)) {
                    setTimeout(() => {
                        if (visibleFiles.some(f => f.id === fileObj.id)) markForDeletion(fileObj.id);
                    }, 500);
                }
            }

            function updateFullscreenDeleteIcon() {
                const isInTrash = trashedFiles.some(f => f.id === currentMediaId);
                fullscreenDeleteBtn.innerHTML = isInTrash ? '&#128472;' : '&#128465;';
                fullscreenDeleteBtn.title = isInTrash ? 'Restore from trash' : 'Mark for deletion';
            }

            fullscreenDeleteBtn.addEventListener('click', e => {
                e.stopPropagation();
                const isInTrash = trashedFiles.some(f => f.id === currentMediaId);
                if(isInTrash) restoreFromTrash(currentMediaId);
                else markForDeletion(currentMediaId);
                closeFullscreen();
            });

            closeFullscreenBtn.addEventListener('click', closeFullscreen);
            prevBtn.addEventListener('click', () => navigateFullscreen(-1));
            nextBtn.addEventListener('click', () => navigateFullscreen(1));
            fullscreenOverlay.addEventListener('click', e => {
                if (e.target === fullscreenOverlay) closeFullscreen();
            });

            function navigateFullscreen(direction) {
                const newIndex = currentMediaIndex + direction;
                if (newIndex >= 0 && newIndex < currentMediaList.length) {
                    openFullscreen(currentMediaList[newIndex]);
                }
            }

            function updateNavigationState() {
                prevBtn.disabled = currentMediaIndex <= 0;
                nextBtn.disabled = currentMediaIndex >= currentMediaList.length - 1;
                const fileObj = currentMediaList[currentMediaIndex];
                if (fileObj) mediaInfo.textContent = `${currentMediaIndex + 1} / ${currentMediaList.length} - ${fileObj.id.split(/[/\\]/).pop()}`;
            }

            function closeFullscreen() {
                fullscreenOverlay.classList.remove('visible');
                fullscreenContent.innerHTML = '';
                currentMediaId = null;
            }

            // --- Global Keyboard Shortcuts ---
            document.addEventListener('keydown', (event) => {
                if (fullscreenOverlay.classList.contains('visible')) {
                    switch(event.key) {
                        case 'Escape': closeFullscreen(); break;
                        case 'ArrowLeft': navigateFullscreen(-1); break;
                        case 'ArrowRight': navigateFullscreen(1); break;
                        case 'i': case 'I':
                            if (currentMediaId) ipcRenderer.send('show-in-explorer', currentMediaId);
                            break;
                    }
                } else {
                    if (event.key === 'm' || event.key === 'M') loadMediaFromPicker();
                }
            });

            // --- Initial Load ---
            initializePage();
        });
    </script>
</body>
</html>
